import React, { useState, useEffect } from 'react';
import toast from 'react-hot-toast';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '@/contexts/AuthContext';
import {
  Box,
  Paper,
  Typography,
  Card,
  CardContent,
  Slider,
  List,
  ListItem,
  ListItemButton,
  ListItemIcon,
  ListItemText,
  Chip,
  Alert,
  CircularProgress,
  Button,
  Divider,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
} from '@mui/material';
import { LoadingButton } from '@mui/lab';
import {
  Handshake as PartnershipIcon,
  CheckCircle as CheckCircleIcon,
  Agriculture as AgricultureIcon,
  LocalDining as ProcessingIcon,
  Search as SearchIcon,
  Delete as DeleteIcon,
  Add as AddIcon,
  Info as InfoIcon,
} from '@mui/icons-material';
import { partnershipsApi } from '@/features/partnerships/services/partnershipsApi';
import type { StepProps } from '../../services/open-shop.types';

// Extended type to include partnership fields from API response
type ExtendedPotentialPartner = {
  existingPartnershipId?: number;
  existingPartnershipStatus?: string;
} & StepProps['formState']['partnerships']['potentialPartners'][0];

// Type for existing partnerships
interface ExistingPartnership {
  partnershipId: number;
  partnerStoreId: number;
  partnerStoreName: string;
  status: 'active' | 'pending' | 'inactive' | 'terminated';
  initiatedByStoreId: number;
  createdAt: string;
  activatedAt?: string;
}

const PartnershipStep: React.FC<StepProps> = ({
  formState,
  updateFormState,
  onNext,
  onPrevious,
}) => {
  const { user } = useAuth();
  const navigate = useNavigate();
  const [partnersLoading, setPartnersLoading] = useState(false);
  const [searchError, setSearchError] = useState<string | null>(null);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [existingPartnerships, setExistingPartnerships] = useState<
    ExistingPartnership[]
  >([]);
  const [existingPartnershipIds, setExistingPartnershipIds] = useState<number[]>(
    []
  );
  const [loadingExistingPartnerships, setLoadingExistingPartnerships] =
    useState(false);
  const [revokeDialogOpen, setRevokeDialogOpen] = useState(false);
  const [partnershipToRevoke, setPartnershipToRevoke] =
    useState<ExistingPartnership | null>(null);
  const [isRevoking, setIsRevoking] = useState(false);
  const isEditMode = !!formState.storeId;

  // Initialize partnership data if not present
  useEffect(() => {
    if (!formState.partnerships) {
      updateFormState({
        partnerships: {
          partnershipRadiusMi: 50,
          selectedPartnerIds: [],
          partnershipType: '',
          potentialPartners: [],
        },
      });
    }
  }, [formState.partnerships, updateFormState]);

  const partnerships = formState.partnerships || {
    partnershipRadiusMi: 50,
    selectedPartnerIds: [],
    partnershipType: '',
    potentialPartners: [],
  };

  // Determine partnership type based on store configuration
  const getPartnershipType = (): string => {
    const storeType = formState.storeBasics.setupFlow?.derivedStoreType;
    const needPartnership = formState.storeBasics.setupFlow?.needPartnership;

    if (needPartnership !== 'yes') return '';

    if (storeType === 'processor') {
      return 'producer'; // Processors need producers
    } else if (storeType === 'producer') {
      return 'processor'; // Producers need processors
    }

    return '';
  };

  // Search for potential partners
  const searchPartners = async () => {
    const partnershipType = getPartnershipType();
    if (!partnershipType || !formState.storeId) {
      setSearchError(
        'Unable to determine partnership type or store ID not available'
      );
      return;
    }

    console.log('ðŸ” Partnership search debug:', {
      storeId: formState.storeId,
      storeIdType: typeof formState.storeId,
      partnershipType,
      radiusMiles: partnerships.partnershipRadiusMi,
    });

    setPartnersLoading(true);
    setSearchError(null);

    try {
      const partners = await partnershipsApi.searchPotentialPartners({
        storeId: formState.storeId,
        partnerType: partnershipType as 'producer' | 'processor',
        radiusMiles: partnerships.partnershipRadiusMi,
      });

      console.log('ðŸ” Partners received from API:', partners);
      console.log(
        'ðŸ” Partners array length:',
        Array.isArray(partners) ? partners.length : 'not array'
      );
      console.log('ðŸ” Partners data:', partners);
      console.log('ðŸ” Form state before update:', formState.partnerships);

      updateFormState({
        partnerships: {
          ...partnerships,
          partnershipType,
          potentialPartners: Array.isArray(partners) ? partners : [],
        },
      });

      console.log(
        'ðŸ” Form state after update - partnerships:',
        formState.partnerships
      );
      console.log(
        'ðŸ” Form state after update - potentialPartners:',
        formState.partnerships?.potentialPartners
      );
    } catch (error) {
      console.error('Partnership search failed:', error);
      setSearchError('Failed to search for partners. Please try again.');
    } finally {
      setPartnersLoading(false);
    }
  };

  // Load existing partnerships from store_partnerships table
  const loadExistingPartnerships = async () => {
    if (!formState.storeId) return;

    setLoadingExistingPartnerships(true);

    try {
      console.log(
        'ðŸ” Loading existing partnerships for store:',
        formState.storeId
      );
      const partnershipsResponse =
        await partnershipsApi.getPartnershipsByStoreId(
          Number(formState.storeId),
          {
            storeId: Number(formState.storeId),
            status: 'active,pending', // Load both active and pending partnerships
          }
        );

      if (partnershipsResponse?.partnerships) {
        // Map partnerships to a cleaner format
        const existingPartnershipsData: ExistingPartnership[] =
          partnershipsResponse.partnerships.map((partnership) => {
            // Determine which store is the partner (not the current store)
            const partnerStoreId =
              partnership.producerStoreId === formState.storeId
                ? partnership.processorStoreId
                : partnership.producerStoreId;

            const partnerStoreName =
              partnership.producerStoreId === formState.storeId
                ? partnership.processorStoreName
                : partnership.producerStoreName;

            return {
              partnershipId: partnership.partnershipId,
              partnerStoreId,
              partnerStoreName,
              status: partnership.status,
              initiatedByStoreId: partnership.initiatedByStoreId,
              createdAt: partnership.createdAt,
              activatedAt: partnership.activatedAt,
            };
          });

        console.log('âœ… Loaded existing partnerships:', existingPartnershipsData);
        setExistingPartnerships(existingPartnershipsData);

        // Extract just the partner IDs
        const partnerIds = existingPartnershipsData.map(
          (p) => p.partnerStoreId
        );
        setExistingPartnershipIds(partnerIds);

        // In edit mode, don't automatically select existing partnerships in the new selections
        // They will be shown separately in the "Existing Partnerships" section
        // Only update selectedPartnerIds with partners that are already selected in the form
        if (!isEditMode) {
          updateFormState({
            partnerships: {
              ...partnerships,
              selectedPartnerIds: partnerIds,
            },
          });
        }
      }
    } catch (error) {
      console.error('âŒ Error loading existing partnerships:', error);
    } finally {
      setLoadingExistingPartnerships(false);
    }
  };

  // Handle revoking a partnership
  const handleRevokePartnership = async () => {
    if (!partnershipToRevoke) return;

    setIsRevoking(true);
    try {
      await partnershipsApi.terminatePartnership(
        partnershipToRevoke.partnershipId,
        'Partnership revoked during store edit'
      );

      toast.success(
        `Partnership with ${partnershipToRevoke.partnerStoreName} has been revoked`
      );

      // Remove from existing partnerships
      setExistingPartnerships(
        existingPartnerships.filter(
          (p) => p.partnershipId !== partnershipToRevoke.partnershipId
        )
      );
      setExistingPartnershipIds(
        existingPartnershipIds.filter(
          (id) => id !== partnershipToRevoke.partnerStoreId
        )
      );

      // Also remove from selected if it was there
      updateFormState({
        partnerships: {
          ...partnerships,
          selectedPartnerIds: partnerships.selectedPartnerIds.filter(
            (id) => id !== partnershipToRevoke.partnerStoreId
          ),
        },
      });

      setRevokeDialogOpen(false);
      setPartnershipToRevoke(null);
    } catch (error) {
      console.error('Error revoking partnership:', error);
      toast.error('Failed to revoke partnership');
    } finally {
      setIsRevoking(false);
    }
  };

  // Save partnerships to database when continuing to next step
  const handleContinue = async () => {
    if (!formState.storeId) {
      toast.error('Store ID not found. Please complete previous steps.');
      return;
    }

    setIsSubmitting(true);
    try {
      console.log('ðŸ¤ Saving partnerships to database...');
      console.log('Selected partner IDs:', partnerships.selectedPartnerIds);
      console.log('Existing partnerships:', existingPartnershipIds);

      // Get partnership type
      const partnershipType = getPartnershipType();
      if (!partnershipType) {
        throw new Error('Unable to determine partnership type');
      }

      // In edit mode: Handle partnerships to be created (new selections)
      const newPartnerIds = partnerships.selectedPartnerIds.filter(
        (id) => !existingPartnershipIds.includes(id)
      );

      // In edit mode: Handle partnerships to be terminated (deselected)
      // Only remove partnerships that were previously existing but are no longer selected
      const terminatedPartnerIds = isEditMode
        ? existingPartnershipIds.filter(
            (id) => !partnerships.selectedPartnerIds.includes(id)
          )
        : [];

      console.log('New partnerships to create:', newPartnerIds);
      console.log('Partnerships to terminate:', terminatedPartnerIds);

      // Create new partnerships - ensure only one record per partnership
      const createPromises = newPartnerIds.map(async (partnerId) => {
        console.log(`ðŸ¤ Creating partnership with partner ${partnerId}`);
        console.log(
          `Store ID: ${formState.storeId}, Partnership Type: ${partnershipType}`
        );

        const createRequest = {
          producerStoreId:
            partnershipType === 'producer'
              ? partnerId
              : Number(formState.storeId),
          processorStoreId:
            partnershipType === 'producer'
              ? Number(formState.storeId)
              : partnerId,
          initiatedByStoreId: Number(formState.storeId),
          partnershipTerms: JSON.stringify({
            services: ['collaboration'],
            notes: 'Partnership created during store setup',
          }),
          deliveryArrangements: JSON.stringify({
            method: 'pickup',
            notes: 'To be determined',
          }),
        };

        console.log(`ðŸ¤ Creating partnership request:`, {
          ...createRequest,
          partnershipType,
          currentStoreId: formState.storeId,
          partnerStoreId: partnerId,
        });
        try {
          const result = await partnershipsApi.createPartnership(createRequest);
          console.log(`âœ… Partnership created successfully:`, result);
          console.log(`âœ… Partnership status: ${result?.status || 'pending'}`);
          return { partnerId, success: true, action: 'created' };
        } catch (createError: unknown) {
          console.error(
            `âŒ Failed to create partnership with partner ${partnerId}:`,
            {
              error: createError,
              request: createRequest,
            }
          );

          // Check if it's a duplicate partnership error
          const errorData = (createError as any)?.response?.data;
          if (
            errorData?.message?.includes('already exists') ||
            errorData?.error?.includes('already exists')
          ) {
            console.log(
              `â„¹ï¸ Partnership already exists with partner ${partnerId}, skipping creation`
            );
            return { partnerId, success: true, action: 'already_exists' };
          }

          throw createError;
        }
      });

      // Terminate deselected partnerships
      const terminatePromises = terminatedPartnerIds.map(async (partnerId) => {
        console.log(`ðŸ¤ Terminating partnership with partner ${partnerId}`);

        // Find the partnership ID for this partner
        const existingPartnership = existingPartnerships.find(
          (p) => p.partnerStoreId === partnerId
        );

        if (existingPartnership) {
          await partnershipsApi.terminatePartnership(
            existingPartnership.partnershipId,
            'Partnership deselected during store edit'
          );
          return { partnerId, success: true, action: 'terminated' };
        } else {
          console.warn(
            `âš ï¸ Could not find partnership ID for partner ${partnerId}`
          );
          return { partnerId, success: false, action: 'terminate_failed' };
        }
      });

      // Wait for all operations to complete
      const results = await Promise.all([
        ...createPromises,
        ...terminatePromises,
      ]);

      const successful = results.filter((r) => r.success).length;
      const total = results.length;
      const created = results.filter((r) => r.action === 'created').length;
      const terminated = results.filter(
        (r) => r.action === 'terminated'
      ).length;

      console.log(
        `âœ… Successfully processed ${successful}/${total} partnerships (${created} created, ${terminated} terminated)`
      );

      if (successful > 0 || total === 0) {
        if (total > 0) {
          toast.success(
            `Successfully updated partnerships (${created} added, ${terminated} removed)`
          );
        }
      }

      // Update existing partnerships state after changes
      const newExistingIds = partnerships.selectedPartnerIds.filter((id) =>
        existingPartnershipIds.includes(id)
      );
      setExistingPartnershipIds(newExistingIds);

      // Proceed to next step
      onNext();
    } catch (error: any) {
      console.error('âŒ Error saving partnerships:', error);

      // Extract detailed error message
      let errorMessage = 'Failed to save partnerships. Please try again.';

      if (error?.response?.data?.message) {
        errorMessage = error.response.data.message;
      } else if (error?.message) {
        errorMessage = error.message;
      } else if (error?.code === 'HTTP_400') {
        errorMessage =
          'Invalid partnership request. Please check the selected partners and try again.';
      }

      console.error('âŒ Detailed partnership error:', {
        status: error?.status,
        code: error?.code,
        message: error?.message,
        response: error?.response?.data,
      });

      toast.error(errorMessage);
    } finally {
      setIsSubmitting(false);
    }
  };

  // Handle partner selection toggle for new partnerships
  const handlePartnerToggle = (partnerId: number) => {
    const currentSelected = partnerships.selectedPartnerIds || [];
    const isAdding = !currentSelected.includes(partnerId);
    const newSelected = isAdding
      ? [...currentSelected, partnerId]
      : currentSelected.filter((id) => id !== partnerId);

    updateFormState({
      partnerships: {
        ...partnerships,
        selectedPartnerIds: newSelected,
      },
      storeBasics: {
        ...formState.storeBasics,
        setupFlow: {
          selectedCategoryIds:
            formState.storeBasics.setupFlow?.selectedCategoryIds || [],
          categoryResponses:
            formState.storeBasics.setupFlow?.categoryResponses || {},
          partnershipRadiusMi:
            formState.storeBasics.setupFlow?.partnershipRadiusMi || 50,
          selectedPartnerIds: newSelected,
          derivedStoreType:
            formState.storeBasics.setupFlow?.derivedStoreType || 'independent',
          derivedCanProduce:
            formState.storeBasics.setupFlow?.derivedCanProduce || false,
          derivedCanProcess:
            formState.storeBasics.setupFlow?.derivedCanProcess || false,
          derivedCanRetail:
            formState.storeBasics.setupFlow?.derivedCanRetail || true,
          needPartnership:
            formState.storeBasics.setupFlow?.needPartnership || 'no',
          partnershipType:
            formState.storeBasics.setupFlow?.partnershipType || '',
        },
      },
    });
  };

  // Handle radius change
  const handleRadiusChange = (newRadius: number) => {
    updateFormState({
      partnerships: {
        ...partnerships,
        partnershipRadiusMi: newRadius,
      },
      storeBasics: {
        ...formState.storeBasics,
        setupFlow: {
          selectedCategoryIds:
            formState.storeBasics.setupFlow?.selectedCategoryIds || [],
          categoryResponses:
            formState.storeBasics.setupFlow?.categoryResponses || {},
          partnershipRadiusMi: newRadius,
          selectedPartnerIds:
            formState.storeBasics.setupFlow?.selectedPartnerIds || [],
          derivedStoreType:
            formState.storeBasics.setupFlow?.derivedStoreType || 'independent',
          derivedCanProduce:
            formState.storeBasics.setupFlow?.derivedCanProduce || false,
          derivedCanProcess:
            formState.storeBasics.setupFlow?.derivedCanProcess || false,
          derivedCanRetail:
            formState.storeBasics.setupFlow?.derivedCanRetail || true,
          needPartnership:
            formState.storeBasics.setupFlow?.needPartnership || 'no',
          partnershipType:
            formState.storeBasics.setupFlow?.partnershipType || '',
        },
      },
    });
  };

  // Auto-search when radius changes and we have a store ID
  useEffect(() => {
    if (formState.storeId && partnerships.partnershipType) {
      const debounceTimer = setTimeout(() => {
        searchPartners();
      }, 500);

      return () => clearTimeout(debounceTimer);
    }
  }, [partnerships.partnershipRadiusMi, formState.storeId]);

  // Load existing partnerships when store ID is available
  useEffect(() => {
    if (formState.storeId) {
      loadExistingPartnerships();
    }
  }, [formState.storeId]);

  // Auto-search when store ID becomes available
  useEffect(() => {
    if (formState.storeId && !partnerships.partnershipType) {
      const partnershipType = getPartnershipType();
      if (partnershipType) {
        updateFormState({
          partnerships: {
            ...partnerships,
            partnershipType,
          },
          storeBasics: {
            ...formState.storeBasics,
            setupFlow: {
              selectedCategoryIds:
                formState.storeBasics.setupFlow?.selectedCategoryIds || [],
              categoryResponses:
                formState.storeBasics.setupFlow?.categoryResponses || {},
              partnershipRadiusMi:
                formState.storeBasics.setupFlow?.partnershipRadiusMi || 50,
              selectedPartnerIds:
                formState.storeBasics.setupFlow?.selectedPartnerIds || [],
              derivedStoreType:
                formState.storeBasics.setupFlow?.derivedStoreType ||
                'independent',
              derivedCanProduce:
                formState.storeBasics.setupFlow?.derivedCanProduce || false,
              derivedCanProcess:
                formState.storeBasics.setupFlow?.derivedCanProcess || false,
              derivedCanRetail:
                formState.storeBasics.setupFlow?.derivedCanRetail || true,
              needPartnership:
                formState.storeBasics.setupFlow?.needPartnership || 'no',
              partnershipType,
            },
          },
        });
        searchPartners();
      }
    }
  }, [formState.storeId]);

  const partnershipType = getPartnershipType();
  const isProcessorStore =
    formState.storeBasics.setupFlow?.derivedStoreType === 'processor';
  const isProducerStore =
    formState.storeBasics.setupFlow?.derivedStoreType === 'producer';

  const getPartnerTypeLabel = () => {
    if (isProcessorStore) return 'Live Animals Producers';
    if (isProducerStore) return 'Meat Processors';
    return 'Partners';
  };

  const getPartnerDescription = () => {
    if (isProcessorStore) {
      return 'Connect with local farms that raise quality livestock for processing.';
    }
    if (isProducerStore) {
      return 'Find local processing facilities that can handle your livestock.';
    }
    return 'Configure your partnership preferences to work with other local businesses.';
  };

  const getStatusColor = (status: string) => {
    if (status === 'active') return 'success';
    if (status === 'pending') return 'warning';
    return 'default';
  };

  const getStatusLabel = (status: string) => {
    if (status === 'active') return 'Active';
    if (status === 'pending') return 'Pending Approval';
    return status;
  };

  return (
    <Box>
      <Typography
        variant='h4'
        component='h2'
        gutterBottom
        sx={{
          fontWeight: 600,
          color: 'text.primary',
          mb: 2,
        }}
      >
        Partnerships - Step 3
      </Typography>

      <Typography variant='body1' color='text.secondary' sx={{ mb: 4 }}>
        {getPartnerDescription()}
      </Typography>

      <Paper
        elevation={1}
        sx={{
          p: 4,
          mb: 4,
          borderRadius: 2,
          border: '1px solid',
          borderColor: 'divider',
        }}
      >
        {/* Show existing partnerships in edit mode */}
        {isEditMode && existingPartnerships.length > 0 && (
          <Card sx={{ mb: 4, border: '2px solid', borderColor: 'success.main' }}>
            <CardContent>
              <Typography
                variant='h6'
                gutterBottom
                sx={{
                  display: 'flex',
                  alignItems: 'center',
                  gap: 1,
                  color: 'success.main',
                }}
              >
                <CheckCircleIcon color='success' />
                Current Active Partnerships
              </Typography>

              <Typography variant='body2' color='text.secondary' sx={{ mb: 3 }}>
                These are your established partnerships. You can add more
                partnerships below or revoke any of these.
              </Typography>

              <List dense>
                {existingPartnerships.map((partnership) => (
                  <ListItem
                    key={partnership.partnershipId}
                    disablePadding
                    sx={{ mb: 1.5 }}
                  >
                    <Card
                      sx={{
                        width: '100%',
                        border: '1px solid',
                        borderColor:
                          partnership.status === 'active'
                            ? 'success.light'
                            : 'warning.light',
                        backgroundColor:
                          partnership.status === 'active'
                            ? 'success.50'
                            : 'warning.50',
                      }}
                    >
                      <CardContent
                        sx={{
                          display: 'flex',
                          justifyContent: 'space-between',
                          alignItems: 'center',
                          py: 2,
                          '&:last-child': { pb: 2 },
                        }}
                      >
                        <Box sx={{ flex: 1 }}>
                          <Typography variant='subtitle2' fontWeight={600}>
                            {partnership.partnerStoreName}
                          </Typography>
                          <Chip
                            label={getStatusLabel(partnership.status)}
                            size='small'
                            color={getStatusColor(partnership.status)}
                            variant='filled'
                            sx={{ mt: 1 }}
                          />
                          {partnership.activatedAt && (
                            <Typography variant='caption' display='block' sx={{ mt: 1 }}>
                              Established:{' '}
                              {new Date(
                                partnership.activatedAt
                              ).toLocaleDateString()}
                            </Typography>
                          )}
                        </Box>
                        <Button
                          size='small'
                          startIcon={<DeleteIcon />}
                          color='error'
                          onClick={() => {
                            setPartnershipToRevoke(partnership);
                            setRevokeDialogOpen(true);
                          }}
                        >
                          Revoke
                        </Button>
                      </CardContent>
                    </Card>
                  </ListItem>
                ))}
              </List>
            </CardContent>
          </Card>
        )}

        {/* Partnership Configuration for adding new partnerships */}
        <Card sx={{ mb: 4 }}>
          <CardContent>
            <Typography
              variant='h6'
              gutterBottom
              sx={{ display: 'flex', alignItems: 'center', gap: 1 }}
            >
              <AddIcon color='primary' />
              {isEditMode && existingPartnerships.length > 0
                ? 'Add More Partnerships'
                : 'Partnership Setup'}
            </Typography>

            <Typography variant='body2' color='text.secondary' sx={{ mb: 3 }}>
              {isEditMode && existingPartnerships.length > 0
                ? `Search for additional ${getPartnerTypeLabel().toLowerCase()} to add to your existing partnerships.`
                : `Configure your search radius to find ${getPartnerTypeLabel().toLowerCase()} in your area.`}
            </Typography>

            <Box sx={{ mb: 3 }}>
              <Typography variant='subtitle2' gutterBottom>
                Search Radius: {partnerships.partnershipRadiusMi} miles
              </Typography>
              <Slider
                value={partnerships.partnershipRadiusMi}
                onChange={(_, value) => handleRadiusChange(value as number)}
                min={10}
                max={200}
                step={10}
                marks
                valueLabelDisplay='auto'
              />
            </Box>

            {!formState.storeId && (
              <Alert severity='info' sx={{ mb: 2 }}>
                Store address information is required to search for partners.
                Please complete the Location & Logistics step first.
              </Alert>
            )}

            {formState.storeId && (
              <Box
                sx={{ display: 'flex', gap: 2, alignItems: 'center', mb: 3 }}
              >
                <Button
                  variant='outlined'
                  startIcon={<SearchIcon />}
                  onClick={searchPartners}
                  disabled={
                    partnersLoading || !partnershipType || loadingExistingPartnerships
                  }
                >
                  {partnersLoading ? 'Searching...' : 'Search Partners'}
                </Button>
                {(partnersLoading || loadingExistingPartnerships) && (
                  <CircularProgress size={24} />
                )}
              </Box>
            )}

            {searchError && (
              <Alert severity='error' sx={{ mb: 2 }}>
                {searchError}
              </Alert>
            )}

            {/* Potential Partners List */}
            {partnerships.potentialPartners.length > 0 && (
              <Box>
                <Typography variant='subtitle2' gutterBottom>
                  Available {getPartnerTypeLabel()} (
                  {partnerships.potentialPartners.length} found):
                </Typography>
                <Typography
                  variant='caption'
                  color='text.secondary'
                  sx={{ display: 'block', mb: 2 }}
                >
                  {isEditMode
                    ? 'Select additional businesses to partner with'
                    : 'Select businesses within your partnership radius'}
                </Typography>

                <List dense>
                  {partnerships.potentialPartners.map(
                    (partner: ExtendedPotentialPartner) => {
                      const isExistingPartner = existingPartnershipIds.includes(
                        partner.storeId
                      );
                      const isSelected =
                        partnerships.selectedPartnerIds.includes(
                          partner.storeId
                        );

                      return (
                        <ListItem
                          key={partner.storeId}
                          disablePadding
                          sx={{ mb: 1 }}
                        >
                          <ListItemButton
                            onClick={() => handlePartnerToggle(partner.storeId)}
                            selected={isSelected}
                            disabled={
                              partnersLoading || isExistingPartner
                            }
                            sx={{
                              border: '1px solid',
                              borderColor: isSelected
                                ? 'success.main'
                                : isExistingPartner
                                  ? 'success.light'
                                  : 'divider',
                              borderRadius: 1,
                              backgroundColor: isExistingPartner
                                ? 'success.50'
                                : undefined,
                              '&:hover': {
                                borderColor: isExistingPartner
                                  ? 'success.light'
                                  : 'primary.main',
                              },
                              '&.Mui-disabled': {
                                opacity: 0.6,
                              },
                            }}
                          >
                            <ListItemIcon>
                              {isExistingPartner ? (
                                <CheckCircleIcon
                                  color='success'
                                  sx={{ fontSize: 24 }}
                                />
                              ) : isSelected ? (
                                <CheckCircleIcon
                                  color='success'
                                  sx={{ fontSize: 24 }}
                                />
                              ) : isProcessorStore ? (
                                <AgricultureIcon color='action' />
                              ) : (
                                <ProcessingIcon color='action' />
                              )}
